
library(scran)
library(scater)
library(PCAtools)
library(BiocSingular)
library(gridExtra)
library(igraph)
library(SingleR)


set.seed(42)


# Feature selection -------------------------------------------------------


plotGeneVar <- function(sce,gene_var,block=NULL,plot_samples=c()) {
  dev.off()
  
  if(missing(gene_var)) {
    gene_var <- modelGeneVar(sce,block)
  }

  if(!is.null(block)) {
    
    blocked_stats <- gene_var$per.block
    
    if(is.null(plot_samples)) {
      plot_samples <- colnames(blocked_stats)
    }
    
    par(mfrow=c(1,length(plot_samples)))

    for (i in plot_samples) {
      current <- blocked_stats[[i]]
      plot(current$mean, current$total, main=i, pch=16, cex=0.5,
           xlab="Mean of log-expression", ylab="Variance of log-expression")
      curfit <- metadata(current)
      curve(curfit$trend(x), col='dodgerblue', add=TRUE, lwd=2) 
      }
    
  } else {
    fit_gv <- metadata(gene_var)
    p <- plot(fit_gv$mean, fit_gv$var, xlab="Mean of log-expression",
              ylab="Variance of log-expression")
    
    p <- p + curve(fit_gv$trend(x), col="dodgerblue", add=TRUE, lwd=2)
  }
  
  return(p)
}


plotGeneCV2 <- function(sce,gene_cv2) {
  if(missing(gene_cv2)) {
    gene_cv2 <- modelGeneCV2(sce)
  }
  
  fit_cv2 <- metadata(gene_cv2)
  plot(fit_cv2$mean, fit_cv2$cv2, log="xy")
  curve(fit_cv2$trend(x), col="dodgerblue", add=TRUE, lwd=2)
}



selectFeatures <- function(sce,method="logvar",ngenes=2000,gene_var) {
  
  if(method=="logvar") {
    if(missing(gene_var)) {gene_var <- modelGeneVar(sce)}
    hvgs <- getTopHVGs(gene_var, n=ngenes,row.names = TRUE)
  } else if(method=="cv2") {
    if(missing(gene_var)) {gene_var <- modelGeneCV2(sce)}
    hvgs <- getTopHVGs(gene_var,n=ngenes,var.field = "ratio",row.names = TRUE)
  } else if(method=="Seurat") {
    seurat <- as.Seurat(sce, counts = "counts", normalized = "logcounts",data=NULL)
    seurat <- FindVariableFeatures(seurat,nfeatures=ngenes)
    hvgs <- VariableFeatures(seurat)
  }

  return(hvgs)
  
}


gethvgSCE <- function(sce,hvgs) {
  sce_hvg <- sce[hvgs,]
  altExp(sce_hvg, "original") <- sce
  return(sce_hvg)
}




# Dimensionality reduction ------------------------------------------------




plotPCAElbow <- function(sce) {
  perc_var <- attr(reducedDim(sce), "percentVar")
  chosen_elbow <- PCAtools::findElbowPoint(perc_var)
  plot(perc_var, xlab="PC", ylab="Variance explained (%)")
  abline(v=chosen_elbow, col="red")
}


plotPerplexityRange <- function(sce,perps=c(5,20,35,50),colour_by="stage") {
  plots = lapply(perps, function(x) {
    sce <- runTSNE(sce,dimred="PCA",perplexity=x)
    plotReducedDim(sce,dimred="TSNE",colour_by=colour_by) + 
                   ggtitle(paste0("perplexity = ",x))
    })
  
  out<-do.call(grid.arrange,  plots)
  
  return(out)
}


plotUMAPNeighbourRange <- function(sce,n_range,min_dist=0.1,colour_by="stage") {
  plots = lapply(n_range, function(x) {
    sce <- runUMAP(sce,dimred="PCA",n_neighbors=x,min_dist=min_dist)
    plotReducedDim(sce,dimred="UMAP",colour_by=colour_by) + 
      ggtitle(paste0("n_neighbours = ",x, " , min_dist = ", min_dist))
  })
  
  out <- do.call(grid.arrange,  plots)
  
  return(out)
}


reducePCA <- function(sce,npcs,approx_SVD=FALSE) {
  if(approx_SVD) {
    sce <- runPCA(sce,BSPARAM=RandomParam(), name="IRLBA")
  } else {
    sce <- runPCA(sce) 
  }
  
  reducedDim(sce, "PCA") <- reducedDim(sce, "PCA")[,1:npcs]
  
  return(sce)  
}






# Clustering --------------------------------------------------------------



louvainCluster <- function(sce,k=10) {
  snn_graph <- buildSNNGraph(sce, k=k, use.dimred = 'PCA')
  clusts <- cluster_louvain(snn_graph)$membership
  table(clusts)
  sce$cluster <- factor(clusts)
  return(sce)
}





# Annotation --------------------------------------------------------------

# Need to get one-to-one's to do this
annotateSingleR <- function(sce,ref_sce) {
  pred_ctypes <- SingleR(test=sce, ref=ref_sce, 
                            labels=ref_sce$celltype, de.method="wilcox")
  
}







