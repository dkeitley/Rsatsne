
library(Matrix)
library(Seurat)
library(biomaRt)

seed = 1234
set.seed(seed)


ensembl=useMart("ensembl")


createDirectories <- function(save.path,datasets) {
  dir.create(save.path,showWarnings = FALSE)

  for (i in datasets) {
    dir.create(paste0(save.path,i),showWarnings=FALSE)
    
    # dir.create(paste0(save.path,i,"/celltype_markers"),showWarnings=FALSE)
    # dir.create(paste0(save.path,i,"/cluster_markers"),showWarnings=FALSE)

    for (j in c("umap","tsne","pca")){
     dir.create(paste0(save.path,i,"/dimplots/",j),showWarnings=FALSE)
    }
  }
}


copyScripts <- function(save.path) {
  file.copy("main.R",save.path,overwrite = TRUE)
  file.copy("utils.R",save.path,overwrite = TRUE)
  file.copy("plot.R",save.path,overwrite = TRUE)
}


sampleDataset <- function(data,n=75) {
  celltypes = unique(data$meta$celltype)
  celltypes = celltypes[!is.na(celltypes)]
  
  cell_list = lapply(celltypes,function(ctype) {
    cells = rownames(data$meta[which(data$meta$celltype == ctype), ])
    n = min(n,length(cells))
    cell_names = sample(cells,n)
    return(cell_names)
  })
  
  data.subset = subset(data$seurat,cells=unlist(cell_list))
  
}




preprocessData <- function(data) {
  data <- NormalizeData(data)
  data <- FindVariableFeatures(data, selection.method = "vst", nfeatures = 2000)
  return(data)
}

processData <- function(data,genes,dims=1:35,resolution=0.8,n_neighbours=30,min_dist=0.5,
                        perplexity=25) {
  data = ScaleData(data,features=genes)
  data <- RunPCA(data, features = VariableFeatures(object = data),seed.use = seed)
  data <- RunUMAP(data, reduction = "pca", dims = dims,n.components = 3L,
                  n.neighbors =n_neighbours,min.dist = min_dist,seed.use = seed )
  data <- FindNeighbors(data, dims = dims)
  data <- FindClusters(data,resolution = resolution,random.seed=seed) # TODO: fine tune resolution
  data <- RunTSNE(data, do.fast = TRUE,check_duplicates=FALSE,perplexity=perplexity)
  return(data)
}






getHomologs <- function(ref_dataset,query_dataset,filter="external_gene_name") {
  
  if(!class(ref_dataset)=="scRNAseqDataset") stop("ref_dataset must be a scRNAseqDataset")
  if(!class(query_dataset)=="scRNAseqDataset") stop("query_dataset must be a scRNAseqDataset")
  
  print("Retrieving homologs from Ensembl. This may take a few minutes...")
  
  mart = useMart("ensembl", dataset = paste0(ref_dataset$ensembl_abbrev,"_gene_ensembl"))
  
  if(filter=="ensembl_gene_id") {
    values=ref_dataset$ensembl_ids
  } else {values=ref_dataset$genes}
  
  homologs = getBM(attributes = c("ensembl_gene_id", "external_gene_name",
                                  paste0(query_dataset$ensembl_abbrev,"_homolog_ensembl_gene"),
                                  paste0(query_dataset$ensembl_abbrev,"_homolog_associated_gene_name"),
                                  paste0(query_dataset$ensembl_abbrev,"_homolog_orthology_type"),
                                  paste0(query_dataset$ensembl_abbrev,"_homolog_orthology_confidence"),
                                  paste0(query_dataset$ensembl_abbrev,"_homolog_perc_id"),
                                  paste0(query_dataset$ensembl_abbrev,"_homolog_perc_id_r1"),
                                  paste0(query_dataset$ensembl_abbrev,"_homolog_goc_score"),
                                  paste0(query_dataset$ensembl_abbrev,"_homolog_wga_coverage")),
                   filters = filter, 
                   values = values,
                   mart = mart)
  return(homologs)
}


# TODO: Make this more general. Check if ensembl id available etc. 
getOne2OneGenes <- function(ref,query,homologs) {
  # filter only one2one homologs 36948 -> 9476
  genes.one2one = homologs[homologs[,
                                    paste0(query$ensembl_abbrev,
                                           "_homolog_orthology_type")
                                    ] == "ortholog_one2one",]
  
  # remove entries with blank query gene name 9476->9471
  genes.one2one = genes.one2one[genes.one2one[,paste0(query$ensembl_abbrev,"_homolog_associated_gene_name")]!="",]
  
  query.homolog_names = genes.one2one[,paste0(query$ensembl_abbrev,"_homolog_associated_gene_name")]
  
  # remove duplicated matches in query dataset gene name 9471-> 9462
  genes.one2one <- genes.one2one[order(query.homolog_names,
                                       genes.one2one[,paste0(query$ensembl_abbrev,"_homolog_orthology_confidence")],
                                       genes.one2one[,paste0(query$ensembl_abbrev,"_homolog_wga_coverage")],decreasing=TRUE), ]
  
  genes.one2one = genes.one2one[ !duplicated(genes.one2one[,paste0(query$ensembl_abbrev,
                                                                  "_homolog_associated_gene_name")]), ]     
  
  # order so that in the same order as ref genes
  genes.one2one = genes.one2one[match(ref$ensembl_ids,genes.one2one$ensembl_gene_id),]
  
  # subset only relevant columns
  query.one2one = genes.one2one[,c('ensembl_gene_id',paste0(query$ensembl_abbrev,'_homolog_associated_gene_name'))]
  
  # remove na values 9462
  query.one2one = query.one2one[!is.na(query.one2one[,2]),]
  
  # filter only those that match name in query dataset 9462->8102
  query.one2one = query.one2one[query.one2one[,2] %in% query$genes,]
  
  return(list(ref=query.one2one[,1],query=query.one2one[,2]))
}


# need to redo
matchDataset <- function(data,ensembl_ids,gene_names) {
  
  ref.counts = data$count_matrix
  ref.ensembl_ids = data$ensembl_ids
  
  rownames(ref.counts)[ref.ensembl_ids %in% ensembl_ids] = gene_names
  seurat = CreateSeuratObject(counts = ref.counts, meta.data = data$meta)
  out = scRNAseqDataset(name=paste0(data$name,"Matched"),path=data$path,species=data$species,
                        ensembl_abbrev=data$ensembl_abbrev,genes=rownames(ref.counts),ensembl_ids=data$ensembl_ids,
                        meta=data$meta,raw=ref.counts
                        ,seurat=seurat,hyperparams=data$hyperparams)
  
  return(out)
}

# temporary hack
matchDatasetSeurat <- function(data,ref.ensembl_ids,ensembl_ids,gene_names) {
  ref.counts = GetAssayData(data,"data")
  rownames(ref.counts)[ref.ensembl_ids %in% ensembl_ids] = gene_names
  seurat = CreateSeuratObject(counts = ref.counts, meta.data = data@meta.data)
  return(seurat)
}




# Need to re-do this. 
filterGenes <- function(data,genes,ensembl_ids="") {
  if(class(data)=="Seurat") {
    
  } else {
    counts = data$count_matrix
  }
  
  
  if(length(ensembl_ids)>1) {
    counts = counts[data$ensembl_ids %in% ensembl_ids,]
  } else {
    counts = counts[data$genes %in% genes,]
  }
  
  seurat = CreateSeuratObject(counts = counts, meta.data = data$meta)
  out = scRNAseqDataset(name=paste0(data$name,"Filtered"),path=data$path,species=data$species,
                        ensembl_abbrev=data$ensembl_abbrev,genes=genes,ensembl_ids=ensembl_ids,
                        meta=data$meta,raw=counts
                        ,seurat=seurat,hyperparams=data$hyperparams)
  return(out)
}

# TODO: Fix problem of duplicate genes
filterGenesSeurat <- function(data,genes,new_genes,assay="counts") {
  counts = GetAssayData(data,assay)
  
  # if ensembl id
  if(grepl("ENS[A-Z]+[0123456789]{11}",x=new_genes[1])) {
    features = genes %in% new_genes
  } else {
    features = unique(as.character(genes[gsub("_","-",genes) %in% new_genes]))
    features = gsub("_","-",features)
  }

  counts = counts[features,]
  counts = counts[order(rownames(counts)),]
  seurat = CreateSeuratObject(counts = counts, meta.data = data@meta.data)
  return(seurat)
}


# need to redo
getGenes <- function(data,ensembl_ids) {
  return(data$genes[data$ensembl_ids %in% ensembl_ids])
}


saveClusterOverlapInfo <- function(raw,filt,filestem) {
  rindex = adj.rand.index(as.integer(raw$seurat_clusters),as.integer(filt$seurat_clusters))
  
  contingency = plotContingencyTable(raw$seurat_clusters,filt$seurat_clusters)
  png(paste0(filestem,"contigency_table.png"))
  print({contingency[[2]] + labs(x="raw",y="filt")})
  dev.off()
  
  lapply(list(rand=rindex,cont_table=contingency[[1]]), write,
         paste0(filestem,"cluster_overlap_info.txt"), append=TRUE, ncolumns=1000)
  
}







