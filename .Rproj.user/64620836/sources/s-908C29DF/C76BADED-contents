#include <Rcpp.h>
#include "tsne.h"
using namespace Rcpp;

Rcpp::List save_results(int N, int no_dims, const std::vector<double>& Y, const std::vector<double>& costs, const std::vector<double>& itercosts,
        double theta, double perplexity, int D, int stop_lying_iter, int mom_switch_iter,
        double momentum, double final_momentum, double eta, double exaggeration_factor);



void run_satsne(TSNE<2> tsne1, TSNE<2> tsne2, NumericMatrix mat12,NumericMatrix mat21, double* X1, int N1, int D1, double* Y1, double* X2, int N2, int D2, double * Y2, bool distance_precomputed, double* costs1, double* costs2, double* itercosts) {

  Rprintf("Inside the run_satsne function...");


  tsne1.initialise(X1, N1, D1, Y1, distance_precomputed, costs1, itercosts);
  tsne2.initialise(X2, N2, D2, Y2, distance_precomputed, costs2, itercosts);

  tsne1.run(X1, mat21, N1, D1, Y1, distance_precomputed, costs1, itercosts);

  //trainIterations(N1, Y1, cost1, itercost);
  //trainIterations(N2, Y2 cost2, itercost);

}







// Function that runs the Barnes-Hut implementation of t-SNE
// [[Rcpp::export]]
void Rsatsne_cpp(NumericMatrix X1, NumericMatrix X2, NumericMatrix mat12,NumericMatrix mat21, int no_dims, double perplexity,
                     double theta, bool verbose, int max_iter,
                     bool distance_precomputed, NumericMatrix Y_in, bool init,
                     int stop_lying_iter, int mom_switch_iter,
                     double momentum, double final_momentum,
                     double eta, double exaggeration_factor, unsigned int num_threads) {

    Rprintf("Running Rsatsne_cpp code...");


    size_t N1 = X1.ncol(), D1 = X1.nrow();
    size_t N2 = X2.ncol(), D2 = X2.nrow();


    double * data1=X1.begin();
    double * data2=X2.begin();



    if (verbose) {
      Rprintf("Read the %i x %i data matrix successfully!\n", N1, D1);
      Rprintf("Read the %i x %i data matrix successfully!\n", N2, D2);
    }
    std::vector<double> Y1(N1 * no_dims), costs1(N1), itercosts(static_cast<int>(std::ceil(max_iter/50.0)));
    std::vector<double> Y2(N2 * no_dims), costs2(N2);



    // Providing user-supplied solution.
    if (init) {
        for (size_t i = 0; i < Y1.size(); i++) Y1[i] = Y_in[i];
        for (size_t i = 0; i < Y2.size(); i++) Y2[i] = Y_in[i];
        if (verbose) Rprintf("Using user supplied starting positions\n");
    }


    // Run tsne
    if (no_dims==1) {
      //SATSNE<1> satsne(perplexity, theta, verbose, max_iter, init, stop_lying_iter, mom_switch_iter,
        //      momentum, final_momentum, eta, exaggeration_factor, num_threads);
      //satsne.run(data, N1, D1, Y1.data(), distance_precomputed, costs.data(), itercosts.data());
    } else if (no_dims==2) {


      Rprintf("About to try initialising two TSNEs...");

      TSNE<2> tsne1(perplexity, theta, verbose, max_iter, init, stop_lying_iter, mom_switch_iter,
                    momentum, final_momentum, eta, exaggeration_factor, num_threads);

      TSNE<2> tsne2(perplexity, theta, verbose, max_iter, init, stop_lying_iter, mom_switch_iter,
                    momentum, final_momentum, eta, exaggeration_factor, num_threads);

      run_satsne(tsne1,tsne2,mat12,mat21, data1, N1, D1, Y1.data(), data2, N2,D2,Y2.data(),distance_precomputed, costs1.data(),costs2.data(), itercosts.data());




    } else if (no_dims==3) {
      //TSNE<3> satsne(perplexity, theta, verbose, max_iter, init, stop_lying_iter, mom_switch_iter,
            //  momentum, final_momentum, eta, exaggeration_factor, num_threads);
      //satsne.run(data1, N1, D1, Y1.data(), distance_precomputed, costs1.data(), itercosts.data());
    } else {
      Rcpp::stop("Only 1, 2 or 3 dimensional output is suppported.\n");
    }

   // return Rcpp::List::create(Rcpp::_["Y"]=Rcpp::NumericMatrix(no_dims, N, Y.data()),
     //       Rcpp::_["costs"]=Rcpp::NumericVector(costs.begin(), costs.end()),
       //     Rcpp::_["itercosts"]=Rcpp::NumericVector(itercosts.begin(), itercosts.end()));

}


/*
// Function that runs the Barnes-Hut implementation of t-SNE on nearest neighbor results.
// [[Rcpp::export]]
Rcpp::List Rtsne_nn_cpp(IntegerMatrix nn_dex, NumericMatrix nn_dist,
                     int no_dims, double perplexity,
                     double theta, bool verbose, int max_iter,
                     NumericMatrix Y_in, bool init,
                     int stop_lying_iter, int mom_switch_iter,
                     double momentum, double final_momentum,
                     double eta, double exaggeration_factor, unsigned int num_threads) {

    size_t N = nn_dex.ncol(), K=nn_dex.nrow(); // transposed - columns are points, rows are neighbors.
    if (verbose) Rprintf("Read the NN results for %i points successfully!\n", N);
    std::vector<double> Y(N * no_dims), costs(N), itercosts(static_cast<int>(std::ceil(max_iter/50.0)));

    // Providing user-supplied solution.
    if (init) {
        for (size_t i = 0; i < Y.size(); i++) Y[i] = Y_in[i];
        if (verbose) Rprintf("Using user supplied starting positions\n");
    }

    // Run tsne
    if (no_dims==1) {
      TSNE<1> tsne(perplexity, theta, verbose, max_iter, init, stop_lying_iter, mom_switch_iter,
              momentum, final_momentum, eta, exaggeration_factor, num_threads);
      tsne.run(nn_dex.begin(), nn_dist.begin(), N, K, Y.data(), costs.data(), itercosts.data());
    } else if (no_dims==2) {
      TSNE<2> tsne(perplexity, theta, verbose, max_iter, init, stop_lying_iter, mom_switch_iter,
              momentum, final_momentum, eta, exaggeration_factor, num_threads);
      tsne.run(nn_dex.begin(), nn_dist.begin(), N, K, Y.data(), costs.data(), itercosts.data());
    } else if (no_dims==3) {
      TSNE<3> tsne(perplexity, theta, verbose, max_iter, init, stop_lying_iter, mom_switch_iter,
              momentum, final_momentum, eta, exaggeration_factor, num_threads);
      tsne.run(nn_dex.begin(), nn_dist.begin(), N, K, Y.data(), costs.data(), itercosts.data());
    } else {
      Rcpp::stop("Only 1, 2 or 3 dimensional output is suppported.\n");
    }

    return Rcpp::List::create(Rcpp::_["Y"]=Rcpp::NumericMatrix(no_dims, N, Y.data()),
            Rcpp::_["costs"]=Rcpp::NumericVector(costs.begin(), costs.end()),
            Rcpp::_["itercosts"]=Rcpp::NumericVector(itercosts.begin(), itercosts.end()));
}
*/
